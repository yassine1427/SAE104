{% extends 'base.html.twig' %}

{% block title %}AC13.02 - Lire, ex√©cuter, corriger et modifier un programme{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <style>
        .code-block {
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow-x: auto;
        }
        .code-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
            font-family: 'Consolas', monospace;
        }
    </style>
{% endblock %}

{% block body %}
<div class="container mt-4">
    <h1 class="text-center mb-4">AC13.02 - Lire, ex√©cuter, corriger et modifier un programme</h1>

    <div class="card mb-4">
        <div class="card-header">
            <h2>Preuves</h2>
        </div>
        <div class="card-body">
            <div class="mb-4">
                <div class="code-block">
                    <div class="code-title">Traitement d'un fichier de format FASTA</div>
                    <pre>
import re

# Ouvrir le fichier FASTA en lecture
with open("Proteome.fasta", "r", encoding="utf-8") as file:
    lignes = file.readlines()

# Initialisation du compteur
compteur = 1

# Parcourir les lignes pour extraire les num√©ros d'accession
for ligne in lignes:
    if ligne.startswith(">"):
        # Expression r√©guli√®re pour extraire le num√©ro d'accession
        match = re.search(r">sp\|?(\w+)", ligne)
        if match:
            accession = match.group(1)
            print(f"Proteine {compteur:05d} {accession}")
            compteur += 1</pre>
                </div>

                <div class="code-block">
                    <div class="code-title">Correction des espaces dans un fichier texte</div>
                    <pre>
import re

# Lire le fichier texte avec les espaces incorrects
with open(r"C:\Users\HP\Desktop\texte.txt", "r", encoding="utf-8") as file:
    texte = file.read()

# Remplacer plusieurs espaces par un seul
texte_corrige = re.sub(r"\s+", " ", texte)

# Enregistrer le texte corrig√© dans un nouveau fichier
with open(r"C:\Users\HP\Desktop\textecorrige.txt", "w", encoding="utf-8") as file:
    file.write(texte_corrige)

print("Correction termin√©e : fichier textecorrige.txt enregistr√©.")</pre>
                </div>

                <div class="code-block">
                    <div class="code-title">Suppression des doublons dans un fichier texte</div>
                    <pre>
import re

# Lire le fichier contenant les doublons
with open("doublons.txt", "r", encoding="utf-8") as file:
    texte = file.read()

# Expression r√©guli√®re pour supprimer les doublons cons√©cutifs
texte_corrige = re.sub(r"\b(\w+)\s+\1\b", r"\1", texte, flags=re.IGNORECASE)

# Afficher le texte corrig√©
print("Texte corrig√© :\n")
print(texte_corrige)</pre>
                </div>

                <div class="code-block">
                    <div class="code-title">Recherche d'Expressions r√©guli√®res</div>
                    <pre>
import re

# D√©finition de la regex
regex = r"^(a|aba)+aa$"

# Liste des mots √† tester
mots_valides = ["aa", "abaa", "ababababaa"]
mots_invalides = ["abababa", "aabbaa", "aba", "abababba"]

# Test des mots
for mot in mots_valides + mots_invalides:
    if re.fullmatch(regex, mot):
        print(f"‚úÖ {mot} est valide")
    else:
        print(f"‚ùå {mot} est invalide")</pre>
                </div>

                <div class="code-block">
                    <div class="code-title">Analyse statistique d'un Fichier texte</div>
                    <pre>
import re
from collections import Counter

# Charger le fichier texte
with open("texte.txt", "r", encoding="utf-8") as file:
    texte = file.read()

# Compter les paragraphes (s√©par√©s par des lignes vides)
paragraphes = texte.split("\n\n")
nb_paragraphes = len([p for p in paragraphes if p.strip()])

# Compter les phrases (s√©par√©es par ".", "!", "?")
phrases = re.split(r"[.!?]+", texte)
nb_phrases = len([p for p in phrases if p.strip()])

# Compter les mots (s√©par√©s par espaces et ponctuations)
mots = re.findall(r"\b\w+\b", texte)
nb_mots = len(mots)

# Trouver le mot le plus fr√©quent
compteur_mots = Counter(mots)
mot_plus_frequent, occ_max = compteur_mots.most_common(1)[0]

# Afficher les r√©sultats
print(f"üìä Analyse du fichier texte.txt :")
print(f"‚úÖ Nombre de paragraphes : {nb_paragraphes}")
print(f"‚úÖ Nombre de phrases : {nb_phrases}")
print(f"‚úÖ Nombre de mots : {nb_mots}")
print(f"‚úÖ Mot le plus fr√©quent : '{mot_plus_frequent}' ({occ_max} fois)")</pre>
                </div>

                <div class="code-block">
                    <div class="code-title">Traitement de fichier ICS</div>
                    <pre>
from icalendar import Calendar
from collections import defaultdict
import re

# Charger le fichier ICS
ics_file = "emploi_du_temps.ics"

with open(ics_file, "r", encoding="utf-8") as file:
    calendrier = Calendar.from_ical(file.read())

# Structure pour stocker les cours par type
cours_par_type = defaultdict(list)

# Filtrer les √©v√©nements du semestre 1 (sept 2024 - janv 2025)
for event in calendrier.walk("VEVENT"):
    summary = event.get("SUMMARY")
    date = event.get("DTSTART").dt
    location = event.get("LOCATION", "Inconnue")
    prof = event.get("DESCRIPTION", "Inconnu")

    # Debugging print statements
    print(f"Processing event: {summary}, Date: {date}, Location: {location}, Prof: {prof}")

    # V√©rifier si l'√©v√©nement est dans le semestre 1
    if (date.year == 2024 and date.month >= 9) or (date.year == 2025 and date.month <= 1):
        # D√©terminer le type de cours avec regex
        if re.search(r"\bCM\b", summary, re.IGNORECASE):
            cours_par_type["CM"].append((date, summary, prof, location))
        elif re.search(r"\bTD\b", summary, re.IGNORECASE):
            cours_par_type["TD"].append((date, summary, prof, location))
        elif re.search(r"\bTP\b", summary, re.IGNORECASE):
            cours_par_type["TP"].append((date, summary, prof, location))
        elif re.search(r"\bDS\b", summary, re.IGNORECASE):
            cours_par_type["DS"].append((date, summary, prof, location))
        elif re.search(r"\bSA√â\b", summary, re.IGNORECASE):
            if "Autonomie" in summary:
                cours_par_type["SA√â - Autonomie"].append((date, summary, prof, location))
            else:
                cours_par_type["SA√â - Suivi"].append((date, summary, prof, location))

# Afficher les r√©sultats
print("üìä Analyse de l'emploi du temps (Semestre 1)")
for type_cours, cours in cours_par_type.items():
    print(f"\nüîπ {type_cours} : {len(cours)} s√©ances")
    for date, summary, prof, location in cours:
        print(f"   üìÖ {date} | {summary} | üë®‚Äçüè´ {prof} | üìç {location}")</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="card mb-4">
        <div class="card-header">
            <h2>Analyse r√©flexive</h2>
        </div>
        <div class="card-body">
            <h3>Introduction</h3>
            <p>La comp√©tence AC13.02, qui consiste √† lire, ex√©cuter, corriger et modifier un programme, est essentielle pour tout technicien ou d√©veloppeur en informatique. Au d√©but de mon apprentissage, j'ai rencontr√© des difficult√©s √† comprendre et manipuler du code, mais gr√¢ce √† une d√©marche structur√©e et √† une pratique r√©guli√®re, j'ai r√©ussi √† d√©velopper cette comp√©tence de mani√®re significative. Cette analyse r√©flexive retrace mon parcours, mes d√©fis, et les strat√©gies qui m'ont permis de progresser.</p>

            <h3>√âtat initial : Difficult√©s et lacunes</h3>
            <p>Au d√©but de ma formation, j'ai identifi√© plusieurs lacunes :</p>
            <ul>
                <li>Manque de compr√©hension du code : J'avais du mal √† lire et interpr√©ter des programmes, surtout dans des langages comme Python, C ou Java.</li>
                <li>Probl√®mes de d√©bogage : Je ne savais pas comment identifier et corriger les erreurs dans un programme.</li>
                <li>Difficult√©s √† modifier du code : J'h√©sitais √† apporter des modifications √† un programme existant par crainte de causer des dysfonctionnements.</li>
            </ul>
            <p>Ces difficult√©s m'ont pouss√© √† renforcer mes bases th√©oriques et √† acqu√©rir une exp√©rience pratique.</p>

            <h3>D√©marche de progression</h3>
            <p>Pour surmonter ces obstacles, j'ai adopt√© plusieurs strat√©gies :</p>
            <ul>
                <li>Renforcement des bases th√©oriques : J'ai utilis√© des ressources vari√©es (cours en ligne, manuels, vid√©os) pour comprendre les concepts de base de la programmation (syntaxe, structures de contr√¥le, fonctions, etc.).</li>
                <li>Pratique r√©guli√®re : J'ai particip√© √† des exercices pratiques pour lire, ex√©cuter et modifier des programmes dans diff√©rents langages.</li>
                <li>Apprentissage par l'erreur : Mes erreurs (mauvaises interpr√©tations du code, corrections inefficaces) m'ont permis de mieux comprendre les principes sous-jacents.</li>
                <li>Collaboration et mentorat : Travailler avec des coll√®gues exp√©riment√©s m'a aid√© √† corriger mes erreurs et √† gagner en confiance.</li>
                <li>Utilisation d'outils de d√©veloppement : J'ai appris √† utiliser des environnements de d√©veloppement int√©gr√©s (IDE) et des outils de d√©bogage pour tester et valider mes modifications.</li>
            </ul>

            <h3>R√©sultats et d√©veloppement de la comp√©tence</h3>
            <p>Mes efforts ont port√© leurs fruits :</p>
            <ul>
                <li>Compr√©hension approfondie du code : Je lis et interpr√®te d√©sormais des programmes avec aisance, m√™me dans des langages complexes.</li>
                <li>D√©bogage efficace : Je suis capable d'identifier et de corriger les erreurs dans un programme de mani√®re pr√©cise et rapide.</li>
                <li>Modification de code en confiance : J'apporte des modifications √† des programmes existants en respectant les bonnes pratiques et en minimisant les risques de dysfonctionnements.</li>
                <li>Autonomie : Je peux lire, ex√©cuter, corriger et modifier des programmes en toute autonomie, en adaptant ma d√©marche aux besoins sp√©cifiques.</li>
            </ul>

            <h3>Conclusion</h3>
            <p>Mon parcours dans l'acquisition de la comp√©tence AC13.02 a √©t√© exigeant mais enrichissant. En combinant th√©orie, pratique, collaboration et apprentissage par l'erreur, j'ai d√©velopp√© une ma√Ætrise solide de la lecture, de l'ex√©cution, de la correction et de la modification de programmes. Cette comp√©tence est d√©sormais un atout cl√© pour intervenir efficacement dans des projets de d√©veloppement logiciel, tout en garantissant qualit√© et fiabilit√©. Je reste motiv√© √† continuer d'apprendre et √† m'adapter aux √©volutions technologiques pour exceller dans ce domaine.</p>
        </div>
    </div>
</div>
{% endblock %} 